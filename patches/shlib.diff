diff -dur ./lib/PAR/Intro.pod ../PAR-shlib/lib/PAR/Intro.pod
--- ./lib/PAR/Intro.pod	Sat Mar 22 23:13:10 2003
+++ ../PAR-shlib/lib/PAR/Intro.pod	Sat Mar 29 15:54:58 2003
@@ -216,6 +216,12 @@
 
 =item *
 
+Shared libraries are currently stored in a single location:
+ 
+    /shlib/                     # standard location
+ 
+=item *
+
 Special files:
 
     /MANIFEST                   # index of the PAR's contents
diff -dur ./myldr/main.c ../PAR-shlib/myldr/main.c
--- ./myldr/main.c	Mon Mar 17 08:31:16 2003
+++ ../PAR-shlib/myldr/main.c	Sat Mar 29 15:51:53 2003
@@ -8,6 +8,10 @@
 #include "XSUB.h"
 #include "my_par_pl.c"
 #include "perlxsi.c"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <dirent.h>
 
 /* Workaround for mapstart: the only op which needs a different ppaddr */
 #undef Perl_pp_mapstart
@@ -61,6 +65,97 @@
     GV* tmpgv;
     int options_count;
 
+    char *envtmp;
+    struct stat statbuf;
+    int statresult;
+    const char *ld_library_path  = "LD_LIBRARY_PATH=";
+    const char *par_tmp_dir      = "PAR_TMP_DIR=";
+    const char *par_priv_tmp_dir = "PAR_TEMP=";
+    const char *tmpval;
+    const char *tmpdir;
+    char *ltmpdir;
+    char *ptmpdir;
+    char *privptmpdir;
+    char *stmpdir;
+    char *cur_ld_library_path;
+    pid_t procid;
+    DIR *partmp_dirp;
+    struct dirent *dp;
+    char *subsubdir;
+
+    const char *tmpenv[4] = { "TMPDIR", "TEMP", "TMP", "" };
+    const char *knowntmp[4] = { "C:\\TEMP", "/tmp", "/", "" };
+
+    const char *subdirbuf_prefix = "par_priv.";
+    const char *subdirbuf_suffix = ".tmp";
+    int maxlen_procid;
+
+    tmpdir = NULL;
+    maxlen_procid = 12; /* should suffice a while */
+
+    for ( i = 0 ; tmpdir == NULL && strlen(tmpval = tmpenv[i]) > 0 ; i++ ) {
+        /* fprintf(stderr, "%s: testing env var %s.\n", argv[0], tmpval); */
+        if ( ( envtmp = getenv(tmpval) ) != NULL )
+        {
+            if ( ( statresult = lstat(tmpval, &statbuf) ) == 0 &&
+                 ((statbuf.st_mode & S_IFMT ) == S_IFDIR ||
+                 (statbuf.st_mode & S_IFMT ) == S_IFLNK) &&
+                 access(tmpval, W_OK) == 0 ) {
+                tmpdir = tmpval;
+            }
+        }
+    }
+
+    for ( i = 0 ; tmpdir == NULL && strlen(tmpval = knowntmp[i]) > 0 ; i++ ) {
+        /* fprintf(stderr, "%s: testing env var %s.\n", argv[0], tmpval); */
+        if ( ( statresult = lstat(tmpval, &statbuf) ) == 0 &&
+             ((statbuf.st_mode & S_IFMT ) == S_IFDIR ||
+              (statbuf.st_mode & S_IFMT ) == S_IFLNK) &&
+             access(tmpval, W_OK) == 0 ) {
+            tmpdir = tmpval;
+        }
+    }
+
+    if ( tmpdir == NULL ) {
+        fprintf(stderr, "%s: no suitable temporary directory found - aborting.\n", argv[0]);
+        return 2;
+    }
+    else {
+        /* fprintf(stderr, "%s: found tmpdir %s.\n", argv[0], tmpdir); */
+
+        ptmpdir = (char *)malloc(strlen(par_tmp_dir) + strlen(tmpdir) + 1);
+        strcpy(ptmpdir, par_tmp_dir);
+        strcat(ptmpdir, tmpdir);
+        /* fprintf(stderr, "%s\n", ptmpdir) */;
+        putenv(ptmpdir);
+
+        /* construct our private temporary directory under the newly found tmp dir */
+        procid = getpid();
+        stmpdir = (char *)malloc(strlen(ptmpdir) + strlen(subdirbuf_prefix) + strlen(subdirbuf_suffix) + maxlen_procid + 2);
+        sprintf(stmpdir, "%s/%s%u%s", tmpdir, subdirbuf_prefix, procid, subdirbuf_suffix); /* Unix */
+
+        privptmpdir = (char *)malloc(strlen(par_priv_tmp_dir) + strlen(stmpdir) + 1);
+        strcpy(privptmpdir, par_priv_tmp_dir);
+        strcat(privptmpdir, stmpdir);
+        /* fprintf(stderr, "%s\n", privptmpdir) */;
+        putenv(privptmpdir);
+
+        if ( ( cur_ld_library_path = getenv("LD_LIBRARY_PATH") ) == NULL ) {
+            cur_ld_library_path = "";
+        }
+        if ( strlen(cur_ld_library_path) == 0 ) {
+            ltmpdir = (char *)malloc(strlen(ld_library_path) + strlen(stmpdir) + 1);
+            sprintf(ltmpdir, "%s%s", ld_library_path, stmpdir, cur_ld_library_path);
+        }
+        else {
+            ltmpdir = (char *)malloc(strlen(ld_library_path) + strlen(stmpdir) + strlen(cur_ld_library_path) + 2);
+            sprintf(ltmpdir, "%s%s:%s", ld_library_path, stmpdir, cur_ld_library_path);
+        }
+        /* fprintf(stderr, "%s\n", ltmpdir) */;
+        putenv(ltmpdir);
+    }
+
+
 #if (defined(USE_5005THREADS) || defined(USE_ITHREADS)) && defined(HAS_PTHREAD_ATFORK)
     /* XXX Ideally, this should really be happening in perl_alloc() or
      * perl_construct() to keep libperl.a transparently fork()-safe.
@@ -152,11 +247,37 @@
     /* PL_main_cv = PL_compcv; */
     PL_compcv = 0;
 
+    /* create temporary PAR directory */
+    if ( mkdir(stmpdir, S_IRWXU) != 0 ) {
+        fprintf(stderr, "%s: creation of private temporary subdirectory %s failed - aborting.\n", argv[0], stmpdir);
+        return 2;
+    }
+
     exitstatus = perl_run( my_perl );
     perl_destruct( my_perl );
     perl_free( my_perl );
 
     PERL_SYS_TERM();
+
+    /* remove temporary PAR directory */
+    partmp_dirp = opendir(stmpdir);
+    if ( partmp_dirp != NULL )
+    {
+        /* fprintf(stderr, "%s: removing private temporary subdirectory %s.\n", argv[0], stmpdir); */
+        /* here we simply assume that PAR will NOT create any subdirectories ... */
+        while ( ( dp = readdir(partmp_dirp) ) != NULL ) {
+            if ( strcmp (dp->d_name, ".") != 0 && strcmp (dp->d_name, "..") != 0 )
+            {
+                subsubdir = malloc(strlen(stmpdir) + strlen(dp->d_name) + 2);
+                sprintf(subsubdir, "%s/%s", stmpdir, dp->d_name); /* Unix */
+                unlink(subsubdir);
+                free(subsubdir);
+                subsubdir = NULL;
+            }
+        }
+        closedir(partmp_dirp);
+        rmdir(stmpdir);
+    }
 
     return exitstatus;
 }
diff -dur ./script/par.pl ../PAR-shlib/script/par.pl
--- ./script/par.pl	Sun Mar 23 01:19:06 2003
+++ ../PAR-shlib/script/par.pl	Sat Mar 29 15:51:53 2003
@@ -200,6 +200,15 @@
             $PAR::Heavy::FullCache{$fullname} = $filename;
             $PAR::Heavy::FullCache{$filename} = $fullname;
         }
+        elsif ( $fullname =~ m|^/?shlib/| and defined $ENV{PAR_TEMP} ) {
+            # should be moved to _tempfile()
+            $filename = File::Spec->catfile($ENV{PAR_TEMP},
+                                            $basename . $ext);
+            open $out, '>', $filename or die $!;
+            binmode($out);
+            print $out $buf;
+            close $out;
+        }
         else {
             $require_list{$fullname} = \"$buf";
         }
@@ -459,6 +468,20 @@
 
     push @PAR::LibCache, $zip;
     $PAR::LibCache{$0} = $zip;
+
+    $quiet = !$ENV{PAR_DEBUG};
+    outs(qq(\$ENV{PAR_TEMP} = "$ENV{PAR_TEMP}"));
+
+    foreach my $member ( $zip->members ) {
+        my $member_name = $member->fileName;
+        if ( $member_name =~ m|^/?shlib/(.+)$| and $ENV{PAR_TEMP} ) {
+            my $extract_name = $1;
+            my $dest_name = File::Spec->catfile($ENV{PAR_TEMP}, $extract_name);
+            $member->extractToFileNamed($dest_name);
+            outs(qq(Extracting "$member_name" to "$dest_name", and loading the file));
+            my $libref = DynaLoader::dl_load_file($dest_name, 0x0); # $module->dl_load_flags);
+        }
+    }
     # }}}
 }
 # }}}
@@ -497,10 +520,11 @@
     require PAR::Heavy;
 }
 
+# N.B. we set PAR_TMP_DIR and PAR_TEMP in myldr/main.c
 my $tmpdir;
 sub tmpdir {
     return $tmpdir if defined $tmpdir;
-    my @dirlist = (@ENV{qw(TMPDIR TEMP TMP)}, qw(C:/temp /tmp /));
+    my @dirlist = (@ENV{qw(PAR_TMP_DIR TMPDIR TEMP TMP)}, qw(C:/temp /tmp /));
     {
         if (${"\cTAINT"}) { eval {
             require Scalar::Util;
diff -dur ./script/pp ../PAR-shlib/script/pp
--- ./script/pp	Sat Mar 29 15:51:17 2003
+++ ../PAR-shlib/script/pp	Sat Mar 29 16:43:53 2003
@@ -30,6 +30,7 @@
 our (@Input, $Output);
 our ($logfh);
 our ($par_file);
+our (@SharedLibs);
 
 main();
 
@@ -78,6 +79,7 @@
 
     my %map;
     unshift @INC, @{opt(I) || []};
+    unshift @SharedLibs, @{opt(l) || []};
 
     Module::ScanDeps::scan_deps(
         rv      => \%map,
@@ -154,6 +156,16 @@
         push @manifest, "script/$name";
     }
 
+    foreach my $input (@SharedLibs) {
+        # my $name = $input; # XXX: redundant
+        $size += -s $input;
+
+        my $name = basename($input);
+        vprint 2, "... adding $input as shlib/$name";
+        $zip->addFile($input => "shlib/$name");
+        push @manifest, "shlib/$name";
+    }
+
     $zip->addString(
         ((@Input == 1)
             ? _main_pl_single("script/" . basename($Input[0]))
@@ -280,6 +292,7 @@
         'g|gui',        # No console window
         'h|help',       # Help me
         'I|lib:s@',     # Include directories (FOR PERL, NOT FOR C)
+        'l|link:s@',    # Include additional shared libraries
         'L|log:s',      # Where to log packaging process information
         'o|output:s',   # Output file
         'p|par',        # Generate PAR only
@@ -573,10 +586,6 @@
 Build an executable that does not have a console window. This option is
 ignored on non-MSWin32 platforms or when C<-p> is specified.
 
-=item B<-o>, B<--output>=I<FILE>
-
-Specifies the file name for the final packaged executable.
-
 =item B<-h>, B<--help>
 
 Shows basic usage information.
@@ -585,9 +594,17 @@
 
 Adds the given directories to the perl library file search path.
 
+=item B<-l>, B<--link>=I<FILE>
+
+Adds shared libraries (a.k.a. shared objects or DLLs) to the binary.
+
 =item B<-L>, B<--log>=I<FILE>
 
 Log the output of packaging to a file rather than to stdout.
+
+=item B<-o>, B<--output>=I<FILE>
+
+Specifies the file name for the final packaged executable.
 
 =item B<-p>, B<--par>
 
